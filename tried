SELECT
  event_time AS event_time,
  'ericsson' AS vendor,
  fqdn,
  labels,
  KEY AS metric_name,
  SAFE_CAST(increase_value AS BIGNUMERIC) AS metric_increase_value,
  SAFE_CAST(sum_value AS BIGNUMERIC)      AS metric_sum_value,
  SAFE_CAST(p_90 AS BIGNUMERIC)           AS metric_p_90_value,
  SAFE_CAST(sum_by_value AS BIGNUMERIC)   AS metric_sum_by_value,
  trans_dt,
  DATETIME('2025-08-11 3:00:00') AS schedule_time,
  CURRENT_TIMESTAMP AS updated_timestamp
FROM (
  WITH base_data AS (
    SELECT *,
           MD5(labels) AS checksum
    FROM (
      SELECT DISTINCT
        trans_hr AS event_time,
        fqdn,
             ----clean and normalize label JSON by removing unnecessary fields
   TO_JSON_STRING(JSON_REMOVE(SAFE.PARSE_JSON(labels),'$.__name__','$.jobid','$.job','$.localdn','$.instance','$.write_relabel_group','$.kubernetes_namespace','$.kubernetes_pod_name','$.pod_name','$.applicationId','$.icr_group')) aslabels,
        JSON_VALUE(labels,'$.instance') AS instance,
        LOWER(name) AS KEY,
        SAFE_CAST(NULLIF(value,'NaN') AS FLOAT64) AS value,
        DATE(`timestamp`) AS trans_dt,
        `timestamp`
      FROM `vz-it-pr-gudv-dtwndo-0.aid_dtwin_core_uat_tbls.oracle_cnf_scp_raw_v1_temp`
      WHERE
        -- last 3 hours (exclusive upper bound)
        trans_hr >= TIMESTAMP_SUB(TIMESTAMP_TRUNC('2025-08-11 3:00:00', HOUR), INTERVAL 3 HOUR)
        AND trans_hr <  TIMESTAMP_TRUNC('2025-08-11 3:00:00', HOUR)
        AND trans_dt BETWEEN
              DATE(TIMESTAMP_SUB(TIMESTAMP_TRUNC('2025-08-11 3:00:00', HOUR), INTERVAL 3 HOUR))
          AND DATE(TIMESTAMP_TRUNC('2025-08-11 3:00:00', HOUR))

        -- only rows that actually arrived in those 3 hours
        AND insert_date_utc >= TIMESTAMP_SUB(TIMESTAMP_TRUNC('2025-08-11 3:00:00', HOUR), INTERVAL 3 HOUR)
        AND insert_date_utc <  TIMESTAMP_TRUNC('2025-08-11 3:00:00', HOUR)

        AND trans_dt IS NOT NULL
    )
  ),
  window_data AS (
    SELECT
      trans_dt,
      event_time,
      fqdn,
      labels,
      checksum,
      instance,
      KEY,
      value,
      `timestamp`,
      SAFE_CAST(
        LAG(value) OVER (
          PARTITION BY fqdn, instance, checksum, KEY, event_time
          ORDER BY `timestamp`
        ) AS FLOAT64
      ) AS prev_value,
      FIRST_VALUE(value) OVER (
        PARTITION BY trans_dt, event_time, fqdn, instance, checksum, KEY
        ORDER BY `timestamp` DESC
      ) AS sum_by_value
    FROM base_data
  ),
  reset_adjusted AS (
    SELECT
      event_time,
      fqdn,
      instance,
      trans_dt,
      MAX(labels) AS labels,
      checksum,
      KEY,
      SUM(value) AS sum_value,
      SUM(CASE
            WHEN prev_value IS NULL THEN 0
            WHEN value < prev_value THEN value
            ELSE value - IFNULL(prev_value,0)
          END) AS increase_value,
      APPROX_QUANTILES(value, 100)[OFFSET(90)] AS p_90,
      MAX(sum_by_value) AS sum_by_value
    FROM window_data
    GROUP BY event_time, fqdn, instance, trans_dt, checksum, KEY
  )SELECT
  event_time,
  fqdn,
  trans_dt,
  SAFE.PARSE_JSON(labels)  AS labels,---- convert labels string back to JSON object
  checksum,
  KEY,
  increase_value,
  sum_value,
  p_90,
  sum_by_value
FROM (
  SELECT
  event_time,
  fqdn,
  trans_dt,
  labels,
  checksum,
  KEY,
---- Final aggregation for metrics
  SUM(increase_value) AS increase_value,
  SUM(sum_value) AS sum_value,
  sum(p_90) as p_90,
  sum(sum_by_value) as sum_by_value
FROM
  reset_adjusted
GROUP BY   
  event_time,
  fqdn,
  trans_dt,
  labels,  
  checksum,
  KEY
)
);
